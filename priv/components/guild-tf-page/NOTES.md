# Notes

The `guild-tf-page` component is a drop-in Guild View page component
for TensorBoard. It provides a page header with the project title and
a tab bar for selecting one of the TensorBoard views (scalars, images,
etc.)

Each TensorBoard view is wrapped in a corresponding `guild-tf-*`
component. E.g. the scalars view is wrapped by
`guild-tf-scalars`. Each wrapper relies on `env` that has a `tf`
attribute object, which in turn has `backend` and `router` objects
generated by via `TF.Backend` (see `tf-backend/tf-backend.html`).

`guild-tf-page` acts as middleware, adding the `tf` objects that are
required by its child pages. The web component lifecycle callbacks
(created, ready, etc.) do not lend themselves to this middleware
pattern:

- `created` is called before any of the component properties are set
- `ready` is called after the component's children have been fully
  initialized

We really want a callback in between these two when our properties are
set but children have not been created. This would give us the right
window to decorate `env` with the `tf` objects as middleware.

The web component design wants us to introduce a new property and
compute that using `env` as input:

```javascript
Polymer({
    properties: {
        tfEnv: {
            type: Object,
            computed: 'computeTfEnv(env)'
        }
    },

    computeTfEnv: function(env) {
        Guild.TF.initEnv(env);
        return env;
    }
});
```

We'd then use `tfEnv` when configuring our TF wrappers:

``` html
<guild-tf-scalars env="[[tfEnv]]"></guild-tf-scalars>
```

We could alternatively use a function:

```javascript
Polymer({
    middleware: function(env) {
        Guild.TF.ensureEnvInitialized(env);
        return env;
    }
});
```

``` html
<guild-tf-scalars env="[[middleware(env)]]"></guild-tf-scalars>
```

This is a lot of ceremony however to simply insert elements into `env`
along a call chain. Shame.

All of that said, we can get away with this:

```javascript
Polymer({
    created: function() {
        Guild.TF.initEnv(this.env);
    }
});
```

This takes advantage of the way we dynamically instantiate
components. It only works when the component is created
imperatively. See `tf-view/generate.js` for how we generate a
view. The `env` attribute is set explicitly when the component is
created. This makes `env` available in the `created` callback.

The approach fails if we define our component statically:

``` html
<guild-tf-page env="[[env]]"></guild-tf-page>
```

In this case, we'd need to use one of the two methods above for
adding `tf` into `env`.
